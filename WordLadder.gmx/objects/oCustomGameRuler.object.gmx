<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>2</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//general
prestart = false
prepared = false
prevWord = ''
currWord = ''
//startgame button
OnclickEvent = 1
BStart = instance_create(800,1000, oButton)
BStart.content = 'BEGIN'
BStart.parent = id
//game objects. 1: word list
wl = instance_create(0,0,oWordList)
wl.parent = id
//letters obj
l = instance_create(0,0,oGameLetters)
l.parent = id
//Abil obj
Abil = instance_create(0,0,oGameAbil)
Abil.parent = id
//timer obj
Timer = instance_create(0,0,oGameTimer)
Timer.parent = id
//settings. Col 1: word length, start timer and sec per letters
MinLen = global.custom[?'StartLen']
MaxLen = 9                                  //used in word list  for stretching
SecPerLetter = global.custom[?'Sec'] * 1000
switch global.custom[?'StartTimer'] {
  case 0: Timer.Timer = 30000; break;    //30s
  case 1: Timer.Timer = 45000; break;
  case 2: Timer.Timer = 60000; break;
  case 3: Timer.Timer = 7500*MinLen; break;
  default:
    if global.custom[?'StartTimer'] &lt; 20
      Timer.Timer = 60000
    else
      Timer.Timer = global.custom[?'StartTimer'] * 1000
  }
//Settings: Col 3: banned &amp; Target
switch global.custom[?'Banned'] {
  case 0:
    l.BanArr[0] = 3
    l.BanArr[1] = 10
    l.BanArr[2] = 42
    l.BanArr[3] = 42
    l.BanArr[4] = 66
    l.BanArr[5] = 100
    l.BanArr[6] = 228
    l.BanArr[7] = 9000
    break
  case 1:
    l.BanArr[0] = 3
    l.BanArr[1] = 10
    l.BanArr[2] = 24
    l.BanArr[3] = 42
    l.BanArr[4] = 42
    l.BanArr[5] = 66
    l.BanArr[6] = 100
    l.BanArr[7] = 100
    break
  case 2:
    l.BanArr[0] = 3
    l.BanArr[1] = 10
    l.BanArr[2] = 22
    l.BanArr[3] = 35
    l.BanArr[4] = 42
    l.BanArr[5] = 66
    l.BanArr[6] = 84
    l.BanArr[7] = 98
    break
  }
l.TabuPB.Req = l.BanArr[l.TabuQty]        //fix first thres value
l.TabuVowel = global.custom[?'Vowels']
switch global.custom[?'Green'] {
  case 0: l.TargetQty = 2; break;
  case 1: l.TargetQty = 1; break;
  case 2: l.TargetQty = 0
  }
//settings: col 2. Specials
switch global.custom[?'Dec'] {    //decrements. Todo: object
  case 0:
    DecArr[0] = 3
    DecArr[1] = 10
    DecArr[2] = 24
    DecArr[3] = 42
    DecArr[4] = 66
    DecArr[5] = 98
    DecArr[6] = 100
    break
  case 1:
    DecArr[0] = 10
    DecArr[1] = 42
    DecArr[2] = 42
    DecArr[3] = 66
    DecArr[4] = 66
    DecArr[5] = 98
    DecArr[6] = 228
    break
  case 2:
    DecArr[0] = 9000
    DecArr[1] = 9999
    DecArr[2] = 99999
    DecArr[3] = 999999
    DecArr[4] = 9999999
    DecArr[5] = 99999999
    DecArr[6] = 999999999
    break
  }
DecPB = instance_create(0,30,oProgBar)
DecQty = 0                              //prog: tabuqty + wordlen  - 10
DecPB.Req = DecArr[DecQty]

Shift = false                             //using of ability flag
ShiftPB = instance_create(0,50,oProgBar)  //prog: greens + wordlen
if global.custom[?'Shift']
  ShiftPB.Req = 100                       //linear increase
else
  ShiftPB.Req = 999999999
  
TT = false                                //using of ability TabuType flag
TTNum = -1                                //prog: tabuqty + greens + wordlen
TTPB = instance_create(0,70,oProgBar)
if global.custom[?'Unban']
  TTPB.Req = 200                            //linear increase
else
  TTPB.Req = 999999999

EnableHints = global.custom[?'Hints']
Think = 0                   //one word clockwatch
HintTimeUp = false
HintTooLong = false
HintTimer = 0           //while &gt;0 a new oSquareHint cannot be created
HintObj = -1

//generate first word
for (i=1; i&lt;=MinLen; i++) {
  tmp = irandom_range(0,25) //todo CHECK LOCALE BLYA
  prevWord+= chr(funcChrDecode(tmp))
  }  
  
//create cubeobj
Cube = instance_create(800,600+MinLen*32,oGameCube)
Cube.parent = id
Cube.MinLen = MinLen
Cube.NewLen = MinLen
Cube.w1 = prevWord
Cube.w2 = '    '
Cube.w3 = '    '
Cube.w4 = '    '
Cube.Letters = l

//create stat obj
Stat = instance_create(0,0,oGameStatCounter)
Stat.parent = id
Stat.Cube = Cube
Stat.GameTypeID = 40  //CUSTOM
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if BStart != -1
  instance_destroy(BStart, true)
if HintObj != -1
  instance_destroy(HintObj, true)
instance_destroy(wl, true)
instance_destroy(l, true)
instance_destroy(Abil, true)
instance_destroy(Timer, true)
instance_destroy(DecPB, true)
instance_destroy(ShiftPB, true)
instance_destroy(TTPB, true)
instance_destroy(Cube, true)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if prepared {
  //timer
  if Timer.Timer&lt;=0 {
    prepared = false
    with Stat {event_user(0)}
    instance_destroy(self, true)
    exit
    }
  //process hint
  if EnableHints {
    Think++
    //hint timers
    if HintTimer &gt; 0        //cooldown
      HintTimer--
    if Timer.Timer &lt; 20000  //20s
      HintTimeUp = true
    else if Think &gt; 6666     //2 minutes of thinking...
      HintTooLong = true
    if (HintTimeUp || HintTooLong) &amp;&amp; HintTimer==0  //create
      funcCreateHint()
    }
  //Stats   todo??? Tick counter -&gt; system time
  Stat.ticks++
  }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if BStart&gt;0 {
  if BStart.clicked {
    instance_destroy(BStart,true)
    BStart = -1
    prepared = true
    currWord = string_char_at(prevWord,string_length(prevWord))
    Cube.w1 = currWord
    Timer.active = true
    Timer.LastTime = current_time
    global.profile[?'PSGAMES']++
    }
  }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>click begin</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//alpha background
draw_sprite_ext(sPixel,0,0,0,1600,1200,0,0,0.5)
draw_text(1500,80,string(HintTimer))
//TabuHilight
if TT {
  var xt = Cube.x;
  if Shift xt+= 72
  draw_set_alpha(0.33)
  draw_set_color(c_white)
  j = MinLen*32
  draw_rectangle(xt-j+TTNum*72,Cube.y-j-100,xt-j+TTNum*72+66,Cube.y-j-34,false)
  }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="40">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if !prepared
  exit
  
if Cube.Rot
  exit

if Abil.Value[1] &gt; 0
  if !Shift {
    Shift = true
    currWord = string_char_at(prevWord, string_length(prevWord)-1)
    Cube.w1 = currWord
    Cube.NewWord = true
    Cube.Shifted = true
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="38">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if !prepared
  exit
  
if Cube.Rot
  exit

if Shift {
    Shift = false
    currWord = string_char_at(prevWord, string_length(prevWord))
    Cube.w1 = currWord
    Cube.NewWord = true
    Cube.Shifted = false
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if !prepared
  exit
  
if Cube.Rot
  exit
  
Stat.attempts++

//check len
if string_length(currWord) &lt; MinLen {
  Cube.LengthErr = true
  Stat.lens++
  exit
  }
  
//check tabu
for (i=2; i&lt;=string_length(currWord); i++) {
  j = ds_list_find_index(l.TabuList, string_char_at(currWord,i))
  if (j != -1) &amp;&amp; (j != TTNum) {
    Timer.Timer-= 5000
    Cube.TabuErr = true
    Cube.TabuErrNum = j
    Stat.tabus++
    exit
    } 
  }

//check prevword
if wordlistTyped(wl,currWord, true) {
  Timer-= 5000
  Stat.prevs++
  exit
  }                                                      
    
//check dict
var tmpm, tmpl, tmp;
  //first lv find
  tmpm = ds_map_find_value(global.DictDS,string_char_at(currWord,1))
  if tmpm != -1
    {
    tmpl = ds_map_find_value(tmpm,string_char_at(currWord,2))
    if tmpl != -1
      {
      tmp = ds_list_find_index(tmpl,currWord)
      if tmp != -1
        {
        //count fields
        var ws = Stat.words;                    //words total
        var ls = string_length(currWord);       //letters in current word
        var ms = Timer.Timer div 60000;         //minutes on timer
        var bs = ds_list_size(l.TabuList);      //banned
        var ts = 0;                             //target letters
        for (i=0; i&lt; ds_list_size(l.TargetList); i++)       //count ts
          ts+= string_count(l.TargetList[| i],prevWord)
        //stats count
        Stat.words++
        Stat.lettersa+= ls
        Stat.pp+= ws + ms + ls + ts
        Stat.targetsa+= ts
        Stat.targets+= ds_list_size(l.TargetList)
        Stat.banned+= bs
        //Stat write new word
        Stat.LenWord = currWord
        with Stat {event_user(2)}
        //write word and proceed
        wordlistAddWord(wl,currWord)
        prevWord = currWord
        MinLen = string_length(currWord)
        if MinLen &gt; MaxLen                //MaxLength to adjust scale in wlist
          MaxLen = MinLen
        if MinLen &gt; 15                    //Const Max Length: 15. todo?
          MinLen = 15
        currWord = string_char_at(currWord, string_length(currWord))
        //Timer bonus
        Timer.Timer+= (ls-1)*SecPerLetter - Timer div 60        //every minute on timer
        //shift usage                                            //causes loss f one second
        if Shift {
          abilChange(Abil, 1, -1)
          Stat.shiftsu++
          Shift = false
          }
        //ban usage
        if TT {
          TT = false
          TTNum = -1
          abilChange(Abil, 2, -1)
          Stat.unbansu++
          }
        //Shift progress
        ShiftPB.Prog+= ls + ts
        if ShiftPB.Prog &gt;= ShiftPB.Req {
          ShiftPB.Prog-= ShiftPB.Req
          ShiftPB.Req+= MinLen
          abilChange(Abil, 1, 1)
          Stat.shiftsa++
          }
        ShiftPB.Anim = true                                     //todo refactor: pb anim functon
        ShiftPB.AnimXTarget = ShiftPB.Prog / ShiftPB.Req * 1600
        //TT prog
        TTPB.Prog+= ls + ts + bs
        if TTPB.Prog &gt;= TTPB.Req {
          TTPB.Prog-= TTPB.Req
          TTPB.Req+= TTPB.Req div 42
          abilChange(Abil, 2, 1)
          Stat.unbansa++
          }
        TTPB.Anim = true
        TTPB.AnimXTarget = TTPB.Prog / TTPB.Req * 1600
        //length dec calc
        var decr = ls + bs - 9
        if decr &gt; 0 {
          DecPB.Prog+= decr
          if DecPB.Prog &gt;= DecPB.Req {
            DecPB.Prog-= DecPB.Req
            DecQty++
            MinLen--
            Stat.decrements++
            DecPB.Req = DecArr[DecQty]
            }
          DecPB.Anim = true
          DecPB.AnimXTarget = DecPB.Prog / DecPB.Req * 1600
          }
        //letters refresh
        with l {lettersNext()}
        //HintRefresh
        HintTimeUp = false
        HintTooLong = false
        Think = 0
        HintTimer+= 420
        //Cube Operations: Rotate &amp; Refresh word 
        Cube.Rot = true
        Cube.LengthErrTick = 0
        Cube.LengthErr = false
        Cube.NewLen = MinLen
        Cube.TabuErr = false
        Cube.TabuErrNum = -1
        }
      else {
        Timer.Timer-= 5000
        Cube.LengthErr = true
        Stat.dicts++
        }
      }
    else {
      Timer.Timer-= 5000
      Cube.LengthErr = true
      Stat.dicts++
      }
    }
  else {
    Timer.Timer-= 5000
    Cube.LengthErr = true
    Stat.dicts++
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if !prepared
  exit
  
if Cube.Rot
  exit 
  
if keyboard_check_pressed(vk_enter)
  exit
      
//backspacing
if keyboard_check_pressed(vk_backspace) {    
  if string_length(currWord) &gt; 1 {                               //todo ingame cursor
    currWord = string_copy(currWord,1,string_length(currWord)-1)
    Stat.lettersb++
    }
  Cube.TabuErr = false      //reset tabu err if enabled
  Cube.TabuErrNum = -1
  }
//switch Unban ability
else if keyboard_check_pressed(vk_tab) &amp;&amp; Abil.Value[2] &gt; 0 {
  if TT {
    TTNum++
    if TTNum == ds_list_size(l.TabuList) {
      TTNum = -1
      TT = false
      }
    }
  else {
    TT = true
    TTNum = 0
    }
  }
//anykey: force EN layout
else if (keyboard_lastkey &gt;= 65) &amp;&amp; (keyboard_lastkey &lt;= 90) {
  currWord+= chr(keyboard_lastkey)
  keyboard_lastkey = -1
  Stat.letters++
  }
//TODO: LOCALE!!!!! ! ! !
else if (MinLen&gt;=14)||(string_length(currWord)&lt;=MinLen) {
  keyboard_lastchar = string_upper(keyboard_lastchar)
  if (ord(keyboard_lastchar)&gt;64)&amp;&amp;(ord(keyboard_lastchar)&lt;91) {
    currWord+= keyboard_lastchar
    Stat.letters++
    }
  keyboard_lastchar = ''                //reset lastchar if next key is ctrl, alt or similar...
  }

Cube.w1 = currWord  
Cube.NewWord = true
wordlistSetMask(wl, currWord)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
