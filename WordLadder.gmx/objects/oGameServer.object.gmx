<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>2</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>server = network_create_server(network_socket_tcp, 27015, 10);
buffer_send = buffer_create(64, buffer_grow, 1);
buffer_hist = buffer_create(64, buffer_grow, 1);

OnclickEvent = 15
GR = -1
Stat = -1
Players = 1
Ready = 0
Restarting = false
ptp = false
ptpPlayers = 0
PtpPos = 0
PtpPosMax = 0

Plr[0] = instance_create(0,0,oPlayer)
Plr[0].IP = 'localhost'
Plr[0].Name = global.profile[?'PNAME']
Plr[0].ID = global.profile[?'PNETID']

Leavers = ds_list_create()              //init archived plrs list

PlrList = instance_create(0,0,oPlayerList)
PlrList.Players = 1
PlrList.PlsArr = Plr
PlrList.MyPlr = Plr[0]

//general fields
PingTimestamp = 0
PingTimer = 60
BRestart = -1

Chat = instance_create(800,200,oGameChat)
Chat.parent = id
Chat.visible = false

Vote = false        //vote state
VoteP = -1          //initializer
VoteWord = ''
VoteShift = false
VoteBan = false

ServerRID = -1
ServerRefreshTimer = 5000

var gmode;
if ptp
  gmode = '1'
else
  gmode = '0'
http_get(global.domain+'wl/regRoom.php?gmode=' + gmode + '&amp;access_token=' + global.userdata[?'AT'])

if global.config[?'DebugDetailLog']
  funcLogString('server initialized')
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if Restarting {
  buffer_seek(buffer_send, buffer_seek_start, 0);
  buffer_write(buffer_send, buffer_s8, 19) 
  }
else {
  buffer_seek(buffer_send, buffer_seek_start, 0);
  buffer_write(buffer_send, buffer_s8, 17)  
  buffer_write(buffer_send, buffer_string, 'Server shut down') 
  }
for (i=1; i&lt;Players; i++) {
  network_send_packet( Plr[i].Sock, buffer_send, buffer_tell(buffer_send) );
  network_destroy(Plr[i].Sock)
  instance_destroy(Plr[i], true)
  }
    
network_destroy(server)

//send room close request
http_get(global.domain+'wl/delRoom.php?rid=' + string(ServerRID) + '&amp;access_token=' + global.userdata[?'AT'])

//todo: destroy child objects
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>PingTimer--
if PingTimer == 0 {
  PingTimer = 60
  //pinging + ping value broadcast
  buffer_seek(buffer_send, buffer_seek_start, 0);
  buffer_write(buffer_send, buffer_s8, 2)
  buffer_write(buffer_send, buffer_s32, PingTimestamp)
  buffer_write(buffer_send, buffer_s8, Players)
  for (var i=0; i&lt;Players; i++)
    buffer_write(buffer_send, buffer_s16, Plr[i].Ping)
  serverBroadcastSocket()
  //prestart timer sync
  if GR != -1 {
    if !GR.prepared {
      buffer_seek(buffer_send, buffer_seek_start, 0);
      buffer_write(buffer_send, buffer_s8, 11)
      buffer_write(buffer_send, buffer_s32, GR.preTimer)
      serverBroadcastSocket()
      }
    //main timer sync
    else {
      buffer_seek(buffer_send, buffer_seek_start, 0);
      buffer_write(buffer_send, buffer_s8, 12)
      buffer_write(buffer_send, buffer_s32, GR.Timer.Timer)
      serverBroadcastSocket()
      }
    }
  }
  
ServerRefreshTimer--
if (ServerRefreshTimer &lt;= 0) &amp;&amp; (ServerRID != -1)
  serverUpdRoom()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>eid = ds_map_find_value(async_load, "id");
type = ds_map_find_value(async_load, "type");
sock = ds_map_find_value(async_load, "socket");
ip = ds_map_find_value(async_load, "ip");
msg_buff = ds_map_find_value(async_load, "buffer");

//TODO SENDID FIX

if type = network_type_connect {
  var p = Players;
  Plr[p] = instance_create(0,0,oPlayer)
  Plr[p].Sock = sock;
  Plr[p].IP = ip; 
  Plr[p].Name = '[ connecting ]'
  //if GR != -1                   //debug-costyl: ptp reconnect
  //  if GR.prepared
  //    PtpArrPos[Players] = 250    //wtffffffff
  Players++
  parent.tc.online = true
  funcLogString('client ' + Plr[p].IP + ' connected')
  }
else if type = network_type_data {  
  for (var i=0; i &lt; Players; i++)
    if eid == Plr[i].Sock {           //find right player by his eid (aka sock)
      eid = i
      break
      }
  
  var header = buffer_read(msg_buff, buffer_s8);
  funcLogDetail('server recv socket ' + string(header))
  switch(header) {
    //client info socket
    case 0:
      var gv = buffer_read(msg_buff, buffer_s32)
      if gv != global.GameVersion
        //todo errmsg / disconnect socket / rm plr obj
        {
        break
        }
      Plr[eid].ID = buffer_read(msg_buff, buffer_s32)
      Plr[eid].Name = buffer_read(msg_buff, buffer_string)
      //find player w/ same ID (check if reconnect)
      var rc = false;
      for (var i=0; i&lt;ds_list_size(Leavers); i++) {
        var cp = Leavers[|i];
        //check if connected plr in leavers list
        if (cp.ID == Plr[eid].ID) {
          rc = true
          playerCopyData(cp, Plr[eid])
          instance_destroy(cp)
          ds_list_delete(Leavers, i)
          break
          }
        }
      PlrList.Players = Players
      PlrList.PlsArr = Plr
      with PlrList event_user(0)
      //send answer
      buffer_seek(buffer_send, buffer_seek_start, 0);
      buffer_write(buffer_send, buffer_s8, 1)
      buffer_write(buffer_send, buffer_s8, global.GameType)
      buffer_write(buffer_send, buffer_s8, global.profile[?'PLOCALE'])
      buffer_write(buffer_send, buffer_s8, eid)
      buffer_write(buffer_send, buffer_bool, rc)
      network_send_packet( eid, buffer_send, buffer_tell(buffer_send) );
      //update room
      serverUpdRoom()
      break
    
    //client ping pong answer
    case 3:
      var pong = buffer_read(msg_buff, buffer_s32)
      if pong != PingTimestamp
        {}          //TODO Force disconnect plr
      pong = buffer_read(msg_buff, buffer_s32)
      PlsArrPing[eid] = current_time - PingTimestamp
      break
      
    //client plr info BROADCAST      //called after plr request
    case 5:
      buffer_seek(buffer_send, buffer_seek_start, 0);
      buffer_write(buffer_send, buffer_s8, 6)
      buffer_write(buffer_send, buffer_s8, eid)
      buffer_write(buffer_send, buffer_s8, Players)
      for (var i=0; i&lt;Players; i++) {
        buffer_write(buffer_send, buffer_s32, Plr[i].ID)
        buffer_write(buffer_send, buffer_string, Plr[i].Name)
        }
      serverBroadcastSocket()
      break
      
    //requested game rules
    case 8:
      buffer_seek(buffer_send, buffer_seek_start, 0);
      buffer_write(buffer_send, buffer_s8, 7)
      buffer_write(buffer_send, buffer_string, json_encode(global.custom))
      network_send_packet( eid, buffer_send, buffer_tell(buffer_send) );
      break
    
    //player clicked "begin" button  
    case 9:
      if GR.prepared {
        //send word history socket 24
        buffer_seek(buffer_hist, buffer_seek_start, 0);
        buffer_write(buffer_hist, buffer_s8, 24)
        var w = GR.wl;
        buffer_write(buffer_hist, buffer_s32, w.Words)
        for (var i=0; i&lt;w.Words; i++)
          buffer_write(buffer_hist, buffer_string, w.Arr[i])
        network_send_packet( Plr[eid].Sock, buffer_hist, buffer_tell(buffer_hist) );
        //send rdy signal
        buffer_seek(buffer_send, buffer_seek_start, 0);
        buffer_write(buffer_send, buffer_s8, 10)
        buffer_write(buffer_send, buffer_s8, Ready)
        buffer_write(buffer_send, buffer_string, GR.prevWord)
        network_send_packet( Plr[eid].Sock, buffer_send, buffer_tell(buffer_send) );
        //broadcast timer
        buffer_seek(buffer_send, buffer_seek_start, 0);
        buffer_write(buffer_send, buffer_s8, 12)
        buffer_write(buffer_send, buffer_s32, GR.Timer.Timer)
        serverBroadcastSocket()
        //send current game state &amp; score
        serverBroadcastLetters()          //todo: score socket?
        }
      else 
        serverClickReady(eid)
      break
    
    //player input
    case 13:
      GR.myWord = false                               //reinsure. It is neccesary?
      var TTNum = buffer_read(msg_buff, buffer_s8);
      var Shift = buffer_read(msg_buff, buffer_bool);
      var enter = buffer_read(msg_buff, buffer_bool);
      var word = buffer_read(msg_buff, buffer_string);
      if enter
        enter = checkWord(word,GR,TTNum)
      var VoteScope = 0;
      if string_length(word) &gt; GR.MinLen
        VoteScope+= 1
      if TTNum != -1
        VoteScope+= 2
      if Shift
        VoteScope+= 4
      Plr[eid].Word = word
      if enter &amp;&amp; ptp {
        var cnt = 0;
        for (var i=0; i&lt; ds_list_size(GR.l.TargetList); i++)
          cnt+= string_count(GR.l.TargetList[| i],word)
        cnt++
        Plr[eid].Score+= cnt
        Plr[eid].ShiftProg+= cnt;
        if Plr[eid].ShiftProg &gt; 33 {
          Plr[eid].ShiftProg-= 33
          Plr[eid].Shift++
          }
        Plr[eid].UnbanProg+= cnt;
        if Plr[eid].UnbanProg &gt; 42 {
          Plr[eid].UnbanProg-= 42
          Plr[eid].Unban++
          }
        Plr[eid].Timer = GR.Timer.Timer + (GR.MinLen-1)*GR.SecPerLetter + cnt*GR.SecPerLetter*0.5
        if string_length(word) &gt; GR.MinLen
          Plr[eid].Timer = Plr[eid].Timer div 2
        if GR.TT
          Plr[eid].Unban--
        if GR.Shift
          Plr[eid].Shift--
        //accept word &amp; send it
        serverAcceptWord(0)  
          
        //AFTER ACCEPTING WORD: CHANGE PLAYER TODO REFACTOR!
        var searching = true;
        while searching {
          PtpPos++
          if PtpPos &gt; PtpPosMax {
            PtpPos = 0
            //GR.ptpwords++           //TODO fix
            }
          for (var i=0; i&lt;Players; i++)
            if Plr[i].Pos == PtpPos &amp;&amp; Plr[i].Playing == true
              searching = false
          }
        for (var i=1; i&lt;Players; i++) {
          //ptp fields
          buffer_seek(buffer_send, buffer_seek_start, 0);
          buffer_write(buffer_send, buffer_s8, 26)
          buffer_write(buffer_send, buffer_s32, Plr[i].Timer)
          if PtpPos == Plr[i].Pos {
            buffer_write(buffer_send, buffer_bool, true)
            GR.Timer.Timer = Plr[i].Timer
            }
          else
            buffer_write(buffer_send, buffer_bool, false)
          buffer_write(buffer_send, buffer_s8, Plr[i].Shift)
          buffer_write(buffer_send, buffer_s8, Plr[i].Unban)
          network_send_packet( Plr[i].Sock, buffer_send, buffer_tell(buffer_send) );
          }
        if Plr[0].Pos == PtpPos {
          GR.myWord = true
          GR.waiting = false
          GR.Cube.ApplyBw = false
          }
        } 
      else if enter &amp;&amp; VoteScope == 0 {       //word ok
        if TTNum != -1
          GR.TT = true
        if Shift
          GR.Shift = true
        GR.currWord = word
        GR.Cube.w1 = word
        serverAcceptWord(eid)
        }
      else if !enter || Vote {          //word not ok  /  or vote initialized yet
        buffer_seek(buffer_send, buffer_seek_start, 0);
        buffer_write(buffer_send, buffer_s8, 14)        //synch draft word
        buffer_write(buffer_send, buffer_s8, eid)
        buffer_write(buffer_send, buffer_bool, false)   //success
        buffer_write(buffer_send, buffer_bool, false)   //unused tt
        buffer_write(buffer_send, buffer_bool, false)   //unused shift
        buffer_write(buffer_send, buffer_string, word)
        serverBroadcastSocket()
        }
      else if VoteScope &gt; 0 {          //word ok: init vote
        VoteP = eid;
        VoteWord = word
        if Shift
          VoteShift = true
        else
          VoteShift = false
        if TTNum &gt;= 0
          VoteBan = true
        else
          VoteBan = false
        Vote = true
        var Desc = 'Vote by ' + Plr[eid].Name + '#';
        switch VoteScope {
          case 1: Desc+= 'Increase word length?#Word: ' + word; break;
          case 2: Desc+= 'Use Unban ability?#Word: ' + word; break;
          case 3: Desc+= 'Use Unban and increase word length?#Word: ' + word; break;
          case 4: Desc+= 'Use Shift ability?#Word: ' + word; break;
          case 5: Desc+= 'Use Shift and increase word length?#Word: ' + word; break;
          case 6: Desc+= 'Use both Unban and Shift abilities?#Word: ' + word; break; 
          case 7: Desc+= 'Use both abilities and increase word length?#Word: ' + word; break;
          }
        buffer_seek(buffer_send, buffer_seek_start, 0);
        buffer_write(buffer_send, buffer_s8, 21)
        buffer_write(buffer_send, buffer_s8, VoteScope)
        buffer_write(buffer_send, buffer_s8, VoteP)
        buffer_write(buffer_send, buffer_string, Desc)
        //todo: optimize buffer
        serverBroadcastSocket()
        voteInit(GR, Desc)
        }
      break 
    
    //chat str
    case 20:
      Chat.GotStr = Plr[eid].Name + ':' + chr(888) + buffer_read(msg_buff, buffer_string);
      buffer_seek(buffer_send, buffer_seek_start, 0);
      buffer_write(buffer_send, buffer_s8, 20)
      buffer_write(buffer_send, buffer_string, Chat.GotStr)
      serverBroadcastSocket()
      with Chat {event_user(0)}
      break
      
    //vote click
    case 22:
      var p = buffer_read(msg_buff, buffer_s8);
      var answer = buffer_read(msg_buff, buffer_bool);
      if answer
        GR.VoteY++
      else
        GR.VoteN++
      //broadcast answer
      buffer_seek(buffer_send, buffer_seek_start, 0);
      buffer_write(buffer_send, buffer_s8, 22)
      buffer_write(buffer_send, buffer_s8, p)
      buffer_write(buffer_send, buffer_bool, answer)
      serverBroadcastSocket()
      //Vote result check
      var isResult = false;
      var Result = false;
      if GR.VoteY / Players &gt; 0.5 {
        isResult = true
        Result = true
        }
      else if GR.VoteN / Players &gt; 0.5
        isResult = true
      else if GR.VoteY + GR.VoteN == Players
        isResult = true
      //VoteResult sent
      if isResult {
        buffer_seek(buffer_send, buffer_seek_start, 0);
        buffer_write(buffer_send, buffer_s8, 23)
        buffer_write(buffer_send, buffer_bool, Result)
        serverBroadcastSocket()
        //Post operations
        Vote = false
        if Result {
          if VoteBan
            GR.TT = true
          if VoteShift
            GR.Shift = true
          GR.currWord = VoteWord
          GR.Cube.w1 = VoteWord
          serverAcceptWord(VoteP)
          }
        else {
          GR.Vote = false
          if VoteP == 0 {
            GR.waiting = false
            GR.Cube.LengthErr = true
            }
          buffer_seek(buffer_send, buffer_seek_start, 0);
          buffer_write(buffer_send, buffer_s8, 14)
          buffer_write(buffer_send, buffer_s8, VoteP)
          buffer_write(buffer_send, buffer_bool, false)
          buffer_write(buffer_send, buffer_bool, false)
          buffer_write(buffer_send, buffer_bool, false)
          buffer_write(buffer_send, buffer_string, VoteWord)
          network_send_packet( Plr[VoteP].Sock, buffer_send, buffer_tell(buffer_send) );
          }
        }
      break
      
      //ptp timer off
    case 27:
      Plr[eid].Playing = false
      ptpPlayers--
      if ptpPlayers &gt; 1 {
        var searching = true;
        while searching {
          PtpPos++
          if PtpPos &gt; PtpPosMax {
            PtpPos = 0
            GR.ptpwords++
            }
          for (var i=0; i&lt;Players; i++)
            if Plr[i].Pos == PtpPos &amp;&amp; Plr[i].Playing == true
              searching = false
          }
        for (var i=1; i&lt;Players; i++)
          {
          //ptp fields
          buffer_seek(buffer_send, buffer_seek_start, 0);
          buffer_write(buffer_send, buffer_s8, 26)
          buffer_write(buffer_send, buffer_s32, Plr[i].Timer)
          if PtpPos == Plr[i].Pos {
            buffer_write(buffer_send, buffer_bool, true)
            GR.Timer = Plr[i].Timer
            }
          else
            buffer_write(buffer_send, buffer_bool, false)
          buffer_write(buffer_send, buffer_s8, Plr[i].Shift)
          buffer_write(buffer_send, buffer_s8, Plr[i].Unban)
          network_send_packet( Plr[i].Sock, buffer_send, buffer_tell(buffer_send) );
          }
        if Plr[0].Pos == PtpPos {
          GR.myWord = true
          GR.waiting = false
          GR.Cube.ApplyBw = false
          }
        }
      else {
        buffer_seek(buffer_send, buffer_seek_start, 0);
        buffer_write(buffer_send, buffer_s8, 28)
        serverBroadcastSocket()
        event_user(4)
        }
      break
    case 30:
      //send 25 cube state
      //todo: first word check?
      buffer_seek(buffer_send, buffer_seek_start, 0);
      buffer_write(buffer_send, buffer_s8, 25)
      buffer_write(buffer_send, buffer_s8, GR.MinLen)
      buffer_write(buffer_send, buffer_string, GR.Cube.w2)
      buffer_write(buffer_send, buffer_string, GR.Cube.w3)
      buffer_write(buffer_send, buffer_string, GR.Cube.w4)
      network_send_packet( Plr[eid].Sock, buffer_send, buffer_tell(buffer_send) );
      //PROGBARS
      buffer_seek(buffer_send, buffer_seek_start, 0);         //refactor socket + join to socket 16
      buffer_write(buffer_send, buffer_s8, 29)            //header
      buffer_write(buffer_send, buffer_s16, GR.ShiftPB.Prog)            //shift prog
      buffer_write(buffer_send, buffer_s16, GR.ShiftPB.Req)            //shift req
      buffer_write(buffer_send, buffer_s16, GR.TTPB.Prog)            //unban prog
      buffer_write(buffer_send, buffer_s16, GR.TTPB.Req)            //unban req
      buffer_write(buffer_send, buffer_s16, GR.DecPB.Prog)            //dec prog
      buffer_write(buffer_send, buffer_s16, GR.DecPB.Req)            //dec req
      network_send_packet( Plr[eid].Sock, buffer_send, buffer_tell(buffer_send) );
      //LOCAL STAT
      buffer_seek(buffer_send, buffer_seek_start, 0);
      buffer_write(buffer_send, buffer_s8, 31)                  //header
      buffer_write(buffer_send, buffer_s32, Plr[eid].Score)       //score
      //todo: other stat synch + reconnect check
      network_send_packet( Plr[eid].Sock, buffer_send, buffer_tell(buffer_send) );
      break
    }
  }
else if type = network_type_disconnect {
  for (var i=0; i&lt;Players; i++)
    if sock == Plr[i].Sock {
      eid = i
      break
      }
   
  //Pl count ?
  if Plr[eid].Ready
    Ready--    
    
  //ptp operations  
  if Plr[eid].Playing
    ptpPlayers--
    
  if ptp {
    if PtpPos == Plr[eid].Pos {
      Plr[eid].Playing = false
      if ptpPlayers &gt; 1 {           //refactor ths plz
        var searching = true;
        while searching {
          PtpPos++
          if PtpPos &gt; PtpPosMax {
            PtpPos = 0
            GR.ptpwords++
            }
          for (var i=0; i&lt;Players; i++)
            if Plr[i].Pos == PtpPos &amp;&amp; Plr[i].Playing == true
              searching = false
          }
        for (var i=1; i&lt;Players; i++) {
          //ptp fields
          buffer_seek(buffer_send, buffer_seek_start, 0);
          buffer_write(buffer_send, buffer_s8, 26)
          buffer_write(buffer_send, buffer_s32, Plr[i].Timer)
          if PtpPos == Plr[i].Pos {
            buffer_write(buffer_send, buffer_bool, true)
            GR.Timer.Timer = Plr[i].Timer
            }
          else
            buffer_write(buffer_send, buffer_bool, false)
          buffer_write(buffer_send, buffer_s8, Plr[i].Shift)
          buffer_write(buffer_send, buffer_s8, Plr[i].Unban)
          network_send_packet( Plr[i].Sock, buffer_send, buffer_tell(buffer_send) );
          }
        if Plr[0].Pos == PtpPos {
          GR.myWord = true
          GR.waiting = false
          GR.Cube.ApplyBw = false
          }
        }
      }
      
    if ptpPlayers &lt; 2
      {
      buffer_seek(buffer_send, buffer_seek_start, 0);
      buffer_write(buffer_send, buffer_s8, 28)
      serverBroadcastSocket()
      event_user(4)
      }
    }
    
  //disconnect socket  
  buffer_seek(buffer_send, buffer_seek_start, 0);
  buffer_write(buffer_send, buffer_s8, 18)
  buffer_write(buffer_send, buffer_s8, eid)
  serverBroadcastSocket()
    
  funcLogString('client ' + Plr[eid].IP + ' disconnected')  
      
  //add Plr to Leavers if he isnt anonymous
  if Plr[eid].ID != 0
    ds_list_add(Leavers, Plr[eid])  
    
  //shift array
  for (var i = eid; i &lt; Players-1; i++)
    Plr[i] = Plr[i+1]
  Players--
  PlrList.PlsArr = Plr
  PlrList.Players = Players
  with PlrList event_user(0)
  
  //update room
  serverUpdRoom()
  }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="62">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//todo: refactor async_load checks!

//data not loaded completely
if async_load[? "status"] != 0
  exit
  
//answer loaded
var html = json_decode(async_load[? "result"])
if html != -1 {
  //check roomid
  if !is_undefined(html[?'ROOMID'])
    ServerRID = string(html[?'ROOMID'])
  funcLogDetail('recv rest roomid')
  }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if BRestart != -1
  if BRestart.clicked {
    Restarting = true
    instance_destroy(self, true)
    instance_destroy(GR, true)
    instance_destroy(Stat, true)
    room_goto(rGame)
    funcLogDetail('server restart')
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ui onclick event</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="17">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ptpLose? wtf is this code</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>PtpArrPlaying[0] = false
ptpPlayers--
if ptpPlayers &gt; 1
  {
  var searching = true;
  while searching
    {
    PtpPos++
    if PtpPos &gt; PtpPosMax
      {
      PtpPos = 0
      GR.ptpwords++
      }
    for (var i=0; i&lt;Players; i++)
      if PtpArrPos[i] == PtpPos &amp;&amp; PtpArrPlaying[i] == true
        searching = false
    }
  for (var i=1; i&lt;Players; i++)
    {
    //ptp fields
    buffer_seek(buffer_send, buffer_seek_start, 0);
    buffer_write(buffer_send, buffer_s8, 26)
    buffer_write(buffer_send, buffer_s32, PtpArrTimer[i])
    if PtpPos == PtpArrPos[i]
      {
      buffer_write(buffer_send, buffer_bool, true)
      GR.Timer = PtpArrTimer[i]
      }
    else
      buffer_write(buffer_send, buffer_bool, false)
    buffer_write(buffer_send, buffer_s8, PtpArrShift[i])
    buffer_write(buffer_send, buffer_s8, PtpArrUnban[i])
    network_send_packet( PlsArrSock[i], buffer_send, buffer_tell(buffer_send) );
    }
  }
else
  {
  buffer_seek(buffer_send, buffer_seek_start, 0);
  buffer_write(buffer_send, buffer_s8, 28)
  serverBroadcastSocket()
  event_user(4)
  with GR {event_user(3)}
  }
funcLogDetail('server event 7')
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="16">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Vote</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//send choice
buffer_seek(buffer_send, buffer_seek_start, 0);
buffer_write(buffer_send, buffer_s8, 22)
buffer_write(buffer_send, buffer_s8, 0)
buffer_write(buffer_send, buffer_bool, GR.VoteChoice)
serverBroadcastSocket()
//Vote result check
var isResult = false;
var Result = false;
if GR.VoteY / Players &gt; 0.5 {
  isResult = true
  Result = true
  }
else if GR.VoteN / Players &gt; 0.5
  isResult = true
else if GR.VoteY + GR.VoteN == Players
  isResult = true
//VoteResult sent
if isResult {
  buffer_seek(buffer_send, buffer_seek_start, 0);
  buffer_write(buffer_send, buffer_s8, 23)
  buffer_write(buffer_send, buffer_bool, Result)
  serverBroadcastSocket()
  //Post operations
  Vote = false
  if Result {
    if VoteBan
      GR.TT = true
    if VoteShift
      GR.Shift = true
    GR.currWord = VoteWord
    GR.Cube.w1 = VoteWord
    serverAcceptWord(VoteP)
    }
  else {
    GR.Vote = false
    if VoteP == 0 {
      GR.waiting = false
      GR.Cube.LengthErr = true
      }
    buffer_seek(buffer_send, buffer_seek_start, 0);
    buffer_write(buffer_send, buffer_s8, 14)
    buffer_write(buffer_send, buffer_s8, VoteP)
    buffer_write(buffer_send, buffer_bool, false)
    buffer_write(buffer_send, buffer_bool, false)
    buffer_write(buffer_send, buffer_bool, false)
    buffer_write(buffer_send, buffer_string, VoteWord)
    network_send_packet( Plr[VoteP].Sock, buffer_send, buffer_tell(buffer_send) );
    }
  }
funcLogDetail('server event 6')
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="15">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>chat event</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Chat.GotStr = Plr[0].Name + ':' + chr(888) + Chat.PendingStr
buffer_seek(buffer_send, buffer_seek_start, 0);
buffer_write(buffer_send, buffer_s8, 20)
buffer_write(buffer_send, buffer_string, Chat.GotStr)
serverBroadcastSocket()
with Chat {event_user(0)}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Gameover event</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>BRestart = instance_create(1328,1100,oButton)
BRestart.content = 'RESTART'
BRestart.parent = id

//Stat passed from GameRuler in step event
GR = -1
with Stat event_user(0)
var bestpl = -1;
var bestsc = -1;
for (var i=0; i&lt;Players; i++)
  if Plr[i].Score &gt; bestsc {
    bestpl = i
    bestsc = Plr[i].Score
    }
var s = 'BEST PLAYER:#';
s+= Plr[bestpl].Name
s+= '##SCORE:#'
s+= string(Plr[bestpl].Name)
Stat.s = s
Chat.visible = false

funcLogDetail('server event 4')

//todo: send endgame socket? It is necessary?

//todo: wtf??? So many bugs and perf degr after endgame
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Ban &amp; Green &amp; Score broadcast</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//trigger letters refresh event
var l = GR.l;
with l lettersNext()
//B &amp; G BROADCAST
serverBroadcastLetters()
  
//SCORE BROADCAST
buffer_seek(buffer_send, buffer_seek_start, 0);
buffer_write(buffer_send, buffer_s8, 16)            //header
buffer_write(buffer_send, buffer_s8, Players)       //pls
for (var i=0; i&lt;Players; i++)
  buffer_write(buffer_send, buffer_s32, Plr[i].Score)
serverBroadcastSocket()
  
funcLogDetail('server event 3')
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>pressed enter</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//word accepted by server. i.e. word have validated yet
//set word vars
var TTNum = GR.TTNum
var Shift = GR.Shift
var enter = true
var word = GR.currWord
var VoteScope = 0;
if string_length(word) &gt; GR.MinLen
  VoteScope+= 1
if TTNum != -1
  VoteScope+= 2
if Shift
  VoteScope+= 4
  
if ptp
  {             //todo: ptp badcode refactor!
  var cnt = 0;
  for (var i=0; i&lt; ds_list_size(GR.l.TargetList); i++)
    cnt+= string_count(GR.l.TargetList[| i],word)
  cnt++
  Plr[0].Score+= cnt
  Plr[0].ShiftProg+= cnt;
  if Plr[0].ShiftProg &gt; 33 {
    Plr[0].ShiftProg-= 33
    Plr[0].Shift++
    }
  Plr[0].UnbanProg+= cnt;
  if Plr[0].UnbanProg &gt; 42 {
    Plr[0].UnbanProg-= 42
    Plr[0].Unban++
    }
  Plr[0].Timer = GR.Timer.Timer + (GR.MinLen-1)*GR.SecPerLetter + cnt*GR.SecPerLetter*0.5
  if string_length(word) &gt; GR.MinLen
    Plr[0].Timer = Plr[0].Timer div 2
  if GR.TT
    Plr[0].Unban--
  if GR.Shift
    Plr[0].Shift--
  //accept word &amp; send it
  serverAcceptWord(0)  
    
  //AFTER ACCEPTING WORD: CHANGE PLAYER TODO REFACTOR!
  var searching = true;
  while searching {
    PtpPos++
    if PtpPos &gt; PtpPosMax {
      PtpPos = 0
      //GR.ptpwords++           //TODO fix
      }
    for (var i=0; i&lt;Players; i++)
      if Plr[i].Pos == PtpPos &amp;&amp; Plr[i].Playing == true
        searching = false
    }
  for (var i=1; i&lt;Players; i++) {
    //ptp fields
    buffer_seek(buffer_send, buffer_seek_start, 0);
    buffer_write(buffer_send, buffer_s8, 26)
    buffer_write(buffer_send, buffer_s32, Plr[i].Timer)
    if PtpPos == Plr[i].Pos {
      buffer_write(buffer_send, buffer_bool, true)
      GR.Timer.Timer = Plr[i].Timer
      }
    else
      buffer_write(buffer_send, buffer_bool, false)
    buffer_write(buffer_send, buffer_s8, Plr[i].Shift)
    buffer_write(buffer_send, buffer_s8, Plr[i].Unban)
    network_send_packet( Plr[i].Sock, buffer_send, buffer_tell(buffer_send) );
    }
  if Plr[0].Pos == PtpPos {
    GR.myWord = true
    GR.waiting = false
    GR.Cube.ApplyBw = false
    }
  }  
//accept word no problemos
else if VoteScope == 0 {
  serverAcceptWord(0)
  }
//initialize vote if word is correct but requires special permissions
//todo: vote refactor. A) special object B) link to object from GR and Net. Delete fields dublication to prevent bugs!
else if !Vote {
  VoteP = 0
  VoteWord = word
  Vote = true
  var Desc = 'Vote by ' + Plr[0].Name+ '#';
  switch VoteScope {
    case 1: Desc+= 'Increase word length?#Word: ' + word; break;
    case 2: Desc+= 'Use Unban ability?#Word: ' + word; break;
    case 3: Desc+= 'Use Unban and increase word length?#Word: ' + word; break;
    case 4: Desc+= 'Use Shift ability?#Word: ' + word; break;
    case 5: Desc+= 'Use Shift and increase word length?#Word: ' + word; break;
    case 6: Desc+= 'Use both Unban and Shift abilities?#Word: ' + word; break; 
    case 7: Desc+= 'Use both abilities and increase word length?#Word: ' + word; break;
    }
  buffer_seek(buffer_send, buffer_seek_start, 0);
  buffer_write(buffer_send, buffer_s8, 21)
  buffer_write(buffer_send, buffer_s8, VoteScope)
  buffer_write(buffer_send, buffer_s8, VoteP)
  buffer_write(buffer_send, buffer_string, Desc)
  serverBroadcastSocket()
  voteInit(GR, Desc)
  }
//can't initialize vote: set fail state to client
else {
  GR.waiting = false
  GR.Cube.LengthErr = true
  }
funcLogDetail('server event 2')
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>input event</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>buffer_seek(buffer_send, buffer_seek_start, 0);
buffer_write(buffer_send, buffer_s8, 14)              //header
buffer_write(buffer_send, buffer_s8, 0)               //player id
buffer_write(buffer_send, buffer_bool, false)         //accept
buffer_write(buffer_send, buffer_bool, false)         //shift
buffer_write(buffer_send, buffer_bool, false)         //unban
buffer_write(buffer_send, buffer_string, GR.currWord)
serverBroadcastSocket()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>"Ready" clicked</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Chat.visible = true
serverClickReady(0)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if !parent.loaded
  exit
  
if Stat != -1
  if Stat.active
    exit

drawTextPreset(fImpact64, c_white, 1, fa_right, fa_top)

draw_text(global.G_RIGHT-5,65,'Players: ' + string(Players))

//prestart string
if GR != -1
  if !GR.prepared {
    s = 'Waiting for players#Ready: ' + string(Ready) + ' / ' + string(Players)
    draw_set_halign(fa_center)
    draw_set_valign(fa_center)
    draw_text(800, 400, s)
    if GR.prestart {
      draw_set_font(fHint)
      draw_text(800,900, 'Start in ' + string(GR.preTimer div 1000)) //todo move from draw event
      }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
