<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>10</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//init values
ARRMAX = 32             //MAINTABLE size const
ARRMAX_PX = ARRMAX*64
tick = 0                //counter
rot = 0                 //field rotation
pxByTick = 1            //pixels by tick aka offset speed
xOffset = 0             //square x-y offset
yOffset = 0
xELeft = 0              //current boundary ID
xERight = ARRMAX - 1
yELeft = 0
yERight = ARRMAX - 1
isHor = false           //hor or vert movement
isReverse = false       //upside-down drawing
revState = 3            //0 wait; 1 op++; 2 op--; 3 begin; 4 ticker;
animType = 0            //0 line; 1 diag; 2 insta; 3 circle in; 4 circle out;
active = false          //is squares clickable?
cheat = ''
ruler = -1              //oMenuSecond instance to check buttons hover
main = -1               //oMenuRuler instance to change header
stuff = -1              //oSquareRuler instance
//background texture parameters
ds = surface_create(2048,2048)
dsx = -224
dsy = -424
recTick = 3
//squares array init
for (i=0; i&lt;ARRMAX; i++)
  for (j=0; j&lt;ARRMAX; j++)
    {
    sqArr[i,j] = instance_create(i*64,j*64,oSquare)
    sqArr[i,j].content = chr(irandom_range(65,90))
    sqArr[i,j].opSq = 0
    sqArr[i,j].opCon = 0
    sqArr[i,j].revState = 0
    sqArr[i,j].parent = id
    sqArr[i,j].image_xscale = 2
    sqArr[i,j].image_yscale = 2
    }
//cheat states
chStop = false
chRestart = false
chReverse = false
chFlip = false
chBlur = false
chAlmi = false
chAlmiTick = 0
chBw = false
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//mem free
for (i=0; i&lt;ARRMAX; i++)
  for (j=0; j&lt;ARRMAX; j++)
    instance_destroy(sqArr[i,j],true)
if surface_exists(ds)
  surface_free(ds)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//animation calc
if !chStop
{
//////////

//FIELD ROTATION
if chReverse
  {
  rot-= 0.125
  if rot &lt;= 0
    rot+= 360
  }
else
  {
  rot+= 0.125
  if rot &gt;= 360
    rot-= 360
  }
    
//OFFSET CHANGING  
if isHor
  {
  xOffset+= pxByTick
  if xOffset &gt;= 64    //complete 1-square shift
    {
    xOffset = 0
    isHor = false
    for (i=0; i&lt;ARRMAX; i+=2) {       //jump boundary square coords
        sqArr[i,yERight].y-= ARRMAX_PX
        sqArr[i+1,yELeft].y+= ARRMAX_PX
        }
    yERight--                       //change boundary IDs
    if yERight == -1
      yERight = ARRMAX-1
    yELeft++
    if yELeft == ARRMAX
      yELeft = 0
    }
  for (i=0; i&lt;ARRMAX; i+=2)      //else just shift
    {
    var i1 = i+1
    for (j=0; j&lt;ARRMAX; j++) {
      sqArr[i,j].y+= pxByTick
      sqArr[i1,j].y-= pxByTick  
      }
    }
  }
else        //symmetric other-axis shifting
  {
  yOffset+= pxByTick
  if yOffset &gt;= 64
    {
    yOffset = 0
    isHor = true
    for (j=0; j&lt;ARRMAX; j+=2) {
        sqArr[xERight,j].x-= ARRMAX_PX
        sqArr[xELeft,j+1].x+= ARRMAX_PX
        }
    xERight--
    if xERight == -1
      xERight = ARRMAX-1
    xELeft++
    if xELeft == ARRMAX
      xELeft = 0
    }
  for (j=0; j&lt;ARRMAX; j+=2)
    {
    var j1 = j+1
    for (i=0; i&lt;ARRMAX; i++) {
      sqArr[i,j].x+= pxByTick
      sqArr[i,j1].x-= pxByTick
      }
    } 
  }
 
//ANIMATION  
if revState != 0 {
  if ceil(tick) == tick
    switch revState
      {
      case 1:                 //change opacity parameter by iterations 
        if animType == 0      //i dont remember how this code works, but it works
          for (i=0; i&lt;ARRMAX; i++) 
            sqArr[tick,i].revState = revState
        else
          for (i=0; i&lt;=tick; i++)
            {
            sqArr[i,tick-i].revState = revState
            sqArr[ARRMAX-1-i,ARRMAX-1-tick+i].revState = revState
            }
        tick+= 0.5
        if tick &gt; ARRMAX-1
          {
          tick = 0
          revState = 0
          }
        break
      case 2:
        if animType == 0
          for (i=0; i&lt;ARRMAX; i++)
            sqArr[tick,i].revState = revState
        else
          for (i=0; i&lt;=tick; i++)
            {
            sqArr[i,tick-i].revState = revState
            sqArr[ARRMAX-1-i,ARRMAX-1-tick+i].revState = revState
            }
        tick+= 0.5
        if tick &gt; ARRMAX - 1
          {
          tick = 0
          revState = 4
          }
        break
      case 3:
        for (i=0; i&lt;ARRMAX; i++)
          sqArr[tick,i].revState = revState
        tick+= 0.5
        if tick &gt; ARRMAX - 1
          {
          tick = 0
          revState = 1
          }
        break
      case 4:
        tick+= 0.5
        if tick &gt; 19
          {
          tick = 0
          revState = 1
          isReverse = funcBoolSwitch(isReverse)
          }
        animType = irandom_range(0,1)  
        break
      }  
  else
    tick+= 0.5
  }
  
//PARAMETERS  
if ((rot == 80) || (rot == 260))
  {
  if revState == 0
    revState = 2
  animType = irandom_range(0,1)
  }
//surface position
dsx = -1024*dcos(rot) - 1024*dsin(rot) + 800
dsy =  1024*dsin(rot) - 1024*dcos(rot) + 600

//squares calc
recTick++
if recTick &gt;= 4 {
  var ax, ay, rax, ray;
  ax[0] = view_xview[0] - dsx -64
  ay[0] = view_yview[0] - dsy -64
  ax[1] = view_xview[0] + view_wview[0] - dsx +64
  ay[1] = view_yview[0] - dsy -64
  ax[2] = view_xview[0] - dsx -64
  ay[2] = view_yview[0] + view_hview[0] - dsy +64
  ax[3] = view_xview[0] + view_wview[0] - dsx +64
  ay[3] = view_yview[0] + view_hview[0] - dsy +64
  for (i=0; i&lt;4; i++) {
    rax[i] =  ax[i]*dcos(-rot) + ay[i]*dsin(-rot)
    ray[i] = -ax[i]*dsin(-rot) + ay[i]*dcos(-rot)
    }
  for (i=0; i&lt;ARRMAX; i++)
    for (j=0; j&lt;ARRMAX; j++)
      if point_in_triangle(sqArr[i,j].x,sqArr[i,j].y, rax[0],ray[0], rax[1],ray[1], rax[2],ray[2])
        sqArr[i,j].draw = true
      else if point_in_triangle(sqArr[i,j].x,sqArr[i,j].y, rax[3],ray[3], rax[1],ray[1], rax[2],ray[2])
        sqArr[i,j].draw = true
      else
        sqArr[i,j].draw = false
  recTick = 0
  }

  
//////////// ch stop
}

if chAlmi
  {
  chAlmiTick++
  if chAlmiTick == 8
    {
    chAlmiTick = 0
    instance_create(0,0,oAlmi)
    //todo: perekat
    }
  }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if ruler == -1
  exit
  
//found square obj covered by cursor
if active 
  if ruler.bHide.hover!=1 &amp;&amp; ruler.bAccept.hover!=1
    {
    //cursor pos calc
    var mx = mouse_x - 800;
    var my = mouse_y - 600;
    var mrx =  mx*dcos(-rot) + my*dsin(-rot) + 1024
    var mry = -mx*dsin(-rot) + my*dcos(-rot) + 1024
    //find square + operate it
    var csq = collision_point(mrx,mry,oSquare,false,true);
    if csq &gt; 0
      {
      csq.clr = irandom_range(6097152,16777215)     //change color
      csq.spr = 1
      cheat+= csq.content
      }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>restart cheat</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//init values
tick = 0                //counter
rot = 0                 //field rotation
pxByTick = 1            //pixels by tick aka offset speed
isReverse = false       //upside-down drawing
revState = 3            //0 wait; 1 op++; 2 op--; 3 begin; 4 ticker;

//cheat states
chStop = false
chReverse = false
chFlip = false
chBlur = false
chAlmi = false
chBw = false
   
if chRestart
  {
  chRestart = false
  revState = 3
  for (i=0; i&lt;ARRMAX; i++)
    for (j=0; j&lt;ARRMAX; j++)
      {
      sqArr[i,j].opSq = 0
      sqArr[i,j].opCon = 0
      sqArr[i,j].revState = 0
      sqArr[i,j].rot = 0
      }
  }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>cheat accept</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//cheat processor, performed from MenuSecond.bAccept
if cheat == 'STOP'                                  //stops animation
  chStop = true
else if (cheat == 'REVERSE')||(cheat == 'TURN')     //switch rotation direction
  chReverse = funcBoolSwitch(chReverse)
else if cheat == 'START'                            //start stopped animation
  chStop = false
else if ((string_count('EASTER',cheat) &gt; 0) || (string_count('EGG',cheat) &gt; 0)) {
  var egg = instance_create(0,0,oEasterEggRuler);   //spawn easter egg obj
  egg.parent = main
  main.Header = 'EASTER EGG'
  }
else if (cheat == 'PREVED') || (cheat == 'HELLO')   //spawn preved obj
  instance_create(0,0,oPreved)
else if cheat == 'SPLASH'                           //get new splash
  with stuff {http_get(global.domain+'wl/getSplash.php')}
else if (cheat == 'EXIT')||(cheat == 'QUIT')          //exit game
  with main.bExit {uiOnclick()}
else if cheat == 'BLUR'                             //apply shLinear shader
  chBlur = true
else if (cheat == 'FLIP') || (cheat == 'SPIN') {      //flip texture vertically
  chFlip = funcBoolSwitch(chFlip)
  isReverse = funcBoolSwitch(isReverse)
  }
else if cheat == 'SHUFFLE'                            //mix some squares and change content
  for (i=0; i&lt;ARRMAX; i++)
    for (j=0; j&lt;ARRMAX; j++)
      {
      if random(1) &gt; 0.69
        continue
      var i1 = irandom_range(0,ARRMAX-1);
      var j1 = irandom_range(0,ARRMAX-1);
      var tmp = sqArr[i,j].content;
      sqArr[i,j].content = sqArr[i1,j1].content
      sqArr[i1,j1].content = tmp
      }
else if cheat == 'RESTART' {                      //restart animation with alpha=0 rot=0
  chRestart = true
  event_user(1)
  }
else if cheat == 'RESET'                          //restart animation and reset cheat parameters
  event_user(1)
else if cheat == 'CANCEL' {                       //turn off cheat parameters
  chStop = false
  chReverse = false
  chBlur = false
  chAlmi = false
  if chFlip {
    chFlip = false
    isReverse = funcBoolSwitch(isReverse)
    }
  }
else if cheat == 'ALMI'                         //spawns almi obj
  chAlmi = true
else if (cheat == 'CALLHIM')||(cheat == 'GAY')    //spawns oCallhim with ProfileName
  instance_create(0,0,oCallhim)
else if string_count('SCR',cheat) &gt; 0           //BOO
  instance_create(0,0,oScreamer)
else if cheat == 'BUG'                          //sets random rotation to all squares
  for (i=0; i&lt;ARRMAX; i++)
    for (j=0; j&lt;ARRMAX; j++)
      sqArr[i,j].rot = irandom_range(0,359)
else if string_count('FIX',cheat) &gt; 0             //cancel BUG effect
  for (i=0; i&lt;ARRMAX; i++)
    for (j=0; j&lt;ARRMAX; j++)
      sqArr[i,j].rot = 0
else if cheat == 'DESIGN' {                       //colorise all letters
  for (i=0; i&lt;ARRMAX; i++)
    for (j=0; j&lt;ARRMAX; j++)
      sqArr[i,j].clr = irandom(c_white)
  cheat = ''
  exit
  }
else if cheat == 'CRUSH'                          //exit game by nullpointer error
  crush++
else if string_count('DICK',cheat) &gt; 0
  {} //todo sound
else if (cheat=='BLACK')||(cheat=='WHITE')          //apply bw shader
  chBw = true
else if (string_count('ACCEL', cheat)&gt;0) || (cheat=='FAST')   //accelerate animation
  pxByTick = 2
else if cheat=='SLOW'                                 //slower animation
  pxByTick = 0.5
      
//refresh
cheat = ''
for (i=0; i&lt;ARRMAX; i++)
  for (j=0; j&lt;ARRMAX; j++)
    {
    sqArr[i,j].clr = c_white    //change color to default
    sqArr[i,j].spr = 0
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
//initial operations
if !surface_exists(ds)
  ds = surface_create(2048,2048)
surface_set_target(ds)
if !chBlur
  draw_clear_alpha(0,0)
//draw square objects
drawTextPreset(fCube,c_white,1,fa_center,fa_center)
for (i=0; i&lt;ARRMAX; i++)
  for (j=0; j&lt;ARRMAX; j++)
    if sqArr[i,j].draw
      {
      draw_sprite_ext(sSquare,sqArr[i,j].spr,sqArr[i,j].x,sqArr[i,j].y,2,2,sqArr[i,j].rot,c_white,sqArr[i,j].opSq)
      if sqArr[i,j].content != -1
        {
        draw_set_color(sqArr[i,j].clr)
        draw_set_alpha(sqArr[i,j].opCon)
        if isReverse
          draw_text_transformed(sqArr[i,j].x+32,sqArr[i,j].y+32,sqArr[i,j].content,1,1,180)
        else
          draw_text(sqArr[i,j].x+32,sqArr[i,j].y+32,sqArr[i,j].content)
        }
      }
surface_reset_target()
//apply bw shader
if chBw
  shader_set(shBw)
draw_surface_ext(ds, dsx, dsy, 1,1, rot, c_white,1)
shader_reset()
//apply linear shader
if chBlur
  {
  shader_set(shLinear)
  var shader_params = shader_get_uniform(shLinear, "tense");
  shader_set_uniform_f(shader_params, 0.8);
  draw_surface_ext(ds, dsx, dsy, 1,1, rot, c_white,1)
  shader_reset()
  }
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
